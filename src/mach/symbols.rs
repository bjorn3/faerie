use crate::Ctx;

use failure::Error;
use indexmap::IndexMap;
use scroll::IOwrite;
use std::io::SeekFrom::*;
use std::io::{Seek, Write};

use goblin::mach::symbols::Nlist;

use super::{SectionIndex, StrTable, StrTableIndex, StrtableOffset};

/// A builder for creating a 32/64 bit Mach-o Nlist symbol
#[derive(Debug)]
pub struct SymbolBuilder {
    name: StrtableOffset,
    section: Option<SectionIndex>,
    global: bool,
    import: bool,
    offset: u64,
    segment_relative_offset: u64,
}

impl SymbolBuilder {
    /// Create a new symbol with `typ`
    pub fn new(name: StrtableOffset) -> Self {
        SymbolBuilder {
            name,
            section: None,
            global: false,
            import: false,
            offset: 0,
            segment_relative_offset: 0,
        }
    }
    /// The section this symbol belongs to
    pub fn section(mut self, section_index: SectionIndex) -> Self {
        self.section = Some(section_index);
        self
    }
    /// Is this symbol global?
    pub fn global(mut self, global: bool) -> Self {
        self.global = global;
        self
    }
    pub fn offset(mut self, offset: u64) -> Self {
        self.offset = offset;
        self
    }
    /// Set the segment relative offset of this symbol, required for relocations
    pub fn relative_offset(mut self, relative_offset: u64) -> Self {
        self.segment_relative_offset = relative_offset;
        self
    }
    /// Returns the offset of this symbol relative to the segment it is apart of
    pub fn get_segment_relative_offset(&self) -> u64 {
        self.segment_relative_offset
    }
    /// Is this symbol an import?
    pub fn import(mut self) -> Self {
        self.import = true;
        self
    }
    /// Finalize and create the symbol
    /// The n_value (offset into section) is still unset, and needs to be generated by the client
    pub fn create(self) -> Nlist {
        use goblin::mach::symbols::{NO_SECT, N_EXT, N_SECT, N_UNDF};
        let n_strx = self.name;
        let mut n_sect = 0;
        let mut n_type = N_UNDF;
        let mut n_value = self.offset;
        let n_desc = 0;
        if self.global {
            n_type |= N_EXT;
        } else {
            n_type &= !N_EXT;
        }
        if let Some(idx) = self.section {
            n_sect = idx + 1; // add 1 because n_sect expects ordinal
            n_type |= N_SECT;
        }

        if self.import {
            n_sect = NO_SECT as usize;
            // FIXME: this is broken i believe; we need to make it both undefined + global for imports
            n_type = N_EXT;
            n_value = 0;
        } else {
            n_type |= N_SECT;
        }

        Nlist {
            n_strx: n_strx as usize,
            n_type,
            n_sect,
            n_desc,
            n_value,
        }
    }
}

/// An index into the symbol table
pub type SymbolIndex = usize;

pub type Symbols = IndexMap<StrTableIndex, SymbolBuilder>;

/// A mach object symbol table
#[derive(Debug, Default)]
pub struct SymbolTable {
    symbols: Symbols,
    strtable: StrTable,
    indexes: IndexMap<StrTableIndex, SymbolIndex>,
    strtable_size: StrtableOffset,
}

/// The kind of symbol this is
pub enum SymbolType {
    /// Which `section` this is defined in, the `absolute_offset` in the binary, and its
    /// `segment_relative_offset`
    Defined {
        section: SectionIndex,
        absolute_offset: u64,
        segment_relative_offset: u64,
        global: bool,
    },
    /// An undefined symbol (an import)
    Undefined,
}

impl SymbolTable {
    /// Create a new symbol table. The first strtable entry (like ELF) is always nothing
    pub fn new() -> Self {
        let mut strtable = StrTable::default();
        strtable.get_or_intern("");
        let strtable_size = 1;
        SymbolTable {
            symbols: Symbols::new(),
            strtable,
            strtable_size,
            indexes: IndexMap::new(),
        }
    }
    /// The number of symbols in this table
    pub fn len(&self) -> usize {
        self.symbols.len()
    }
    /// Returns size of the string table, in bytes
    pub fn sizeof_strtable(&self) -> u64 {
        self.strtable_size
    }
    /// Lookup this symbols offset in the segment
    pub fn offset(&self, symbol_name: &str) -> Option<u64> {
        self.strtable
            .get(symbol_name)
            .and_then(|idx| self.symbols.get(&idx))
            .and_then(|sym| Some(sym.get_segment_relative_offset()))
    }
    /// Lookup this symbols ordinal index in the symbol table, if it has one
    pub fn index(&self, symbol_name: &str) -> Option<SymbolIndex> {
        self.strtable
            .get(symbol_name)
            .and_then(|idx| self.indexes.get(&idx).cloned())
    }
    /// Insert a new symbol into this objects symbol table
    pub fn insert(&mut self, symbol_name: &str, kind: SymbolType) {
        // mach-o requires _ prefixes on every symbol, we will allow this to be configurable later
        //let name = format!("_{}", symbol_name);
        let name = symbol_name;
        // 1 for null terminator and 1 for _ prefix (defered until write time);
        let name_len = name.len() as u64 + 1 + 1;
        let last_index = self.strtable.len();
        let name_index = self.strtable.get_or_intern(name);
        debug!("{}: {} <= {}", symbol_name, last_index, name_index);
        // the string is new: NB: relies on name indexes incrementing in sequence, starting at 0
        if name_index == last_index {
            debug!(
                "Inserting new symbol: {}",
                self.strtable.resolve(name_index).unwrap()
            );
            // TODO: add code offset into symbol n_value
            let builder = match kind {
                SymbolType::Undefined => {
                    SymbolBuilder::new(self.strtable_size).global(true).import()
                }
                SymbolType::Defined {
                    section,
                    absolute_offset,
                    global,
                    segment_relative_offset,
                } => SymbolBuilder::new(self.strtable_size)
                    .global(global)
                    .offset(absolute_offset)
                    .relative_offset(segment_relative_offset)
                    .section(section),
            };
            // insert the builder for this symbol, using its strtab index
            self.symbols.insert(name_index, builder);
            // now create the symbols index, and using strtab name as lookup
            self.indexes.insert(name_index, self.symbols.len() - 1);
            // NB do not move this, otherwise all offsets will be off
            self.strtable_size += name_len;
        }
    }
}

pub fn write<T: Write + Seek>(mut file: T, ctx: Ctx, symtab: SymbolTable) -> Result<(), Error> {
    //////////////////////////////
    // write symtable
    //////////////////////////////
    for (idx, symbol) in symtab.symbols.into_iter() {
        let symbol = symbol.create();
        debug!("{}: {:?}", idx, symbol);
        file.iowrite_with(symbol, ctx)?;
    }
    debug!("SEEK: after symtable: {}", file.seek(Current(0))?);

    //////////////////////////////
    // write strtable
    //////////////////////////////
    // we need to write first, empty element - but without an underscore
    file.iowrite(0u8)?;
    for (idx, string) in symtab.strtable.into_iter().skip(1) {
        debug!("{}: {:?}", idx, string);
        // yup, an underscore
        file.iowrite(0x5fu8)?;
        file.write_all(string.as_bytes())?;
        file.iowrite(0u8)?;
    }
    debug!("SEEK: after strtable: {}", file.seek(Current(0))?);

    Ok(())
}
